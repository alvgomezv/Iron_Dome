#!/irondome/env/bin/python3
#!/goinfre/alvgomez/miniconda3/envs/42cyber-alvgomez/bin/python

import argparse
import os
import time
import daemon
import threading
import logging
import magic
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import math
import psutil 

def parse_arguments():
    parser = argparse.ArgumentParser(description="Program that detects anomalous activity inside a critical zone")                 
    parser.add_argument("args", nargs='*')
    arg = parser.parse_args()
    return arg

def is_root_user():
    return os.geteuid() == 0

def magic_changes(path, ext, past_entropy):
    files = os.listdir(path)
    file_paths = [os.path.join(path, file) for file in files if os.path.isfile(os.path.join(path, file))]
    if ext is not None:
        file_paths = [file for file in file_paths if os.path.splitext(file)[1] in ext]
    if not past_entropy:
        past_entropy = {}
        for file_path in file_paths:
            if os.path.exists(file_path):
                past_entropy[file_path] = calculate_entropy(file_path)
    for key, value in past_entropy.items():
        if os.path.exists(os.path.join(path, key)):
            if value != calculate_entropy(os.path.join(path, key)):
                logging.info(f"Warrning! Entropy changes in: {key}")
                past_entropy[key] = calculate_entropy(os.path.join(path, key))
    print(past_entropy)
    return past_entropy

def calculate_entropy(file_path):
    with open(file_path, 'rb') as file:
        data = file.read()
    byte_count = {}
    total_bytes = len(data)
    for byte in data:
        if byte in byte_count:
            byte_count[byte] += 1
        else:
            byte_count[byte] = 1
    entropy = 0
    for count in byte_count.values():
        probability = count / total_bytes
        entropy -= probability * math.log2(probability)
    return entropy

def entropy_changes(path, ext, past_entropy):
    files = os.listdir(path)
    file_paths = [os.path.join(path, file) for file in files if os.path.isfile(os.path.join(path, file))]
    if ext is not None:
        file_paths = [file for file in file_paths if os.path.splitext(file)[1] in ext]
    if not past_entropy:
        past_entropy = {}
        for file_path in file_paths:
            if os.path.exists(file_path):
                past_entropy[file_path] = calculate_entropy(file_path)
    for key, value in past_entropy.items():
        if os.path.exists(os.path.join(path, key)):
            if value != calculate_entropy(os.path.join(path, key)):
                logging.info(f"Warrning! Entropy changes in: {key}")
                past_entropy[key] = calculate_entropy(os.path.join(path, key))
    print(past_entropy)
    return past_entropy

def memory_usage():
    memory_threshold_MB = 100
    memory_threshold = memory_threshold_MB * 1024 * 1024

    process = psutil.Process()
    memory_usage = process.memory_info().rss
    if memory_usage > memory_threshold:
        logging.info(f"WARNING! Memory usage exeeded {memory_threshold_MB}MB, program stoped")
        exit()

class Events(FileSystemEventHandler):
    def __init__(self, file_path, ext, time_frame, max_mod, max_create, max_del):
        super().__init__()
        self.file_path = file_path
        self.ext = ext
        self.time_frame = time_frame
        self.max_mod = max_mod
        self.max_create = max_create
        self.max_del = max_del
        self.mod_counter = 0
        self.create_counter = 0
        self.del_counter = 0

    def on_modified(self, event):
        if self.ext is not None:
            if os.path.splitext(event.src_path)[1] in self.ext:
                self.mod_counter += 1
        else:
            self.mod_counter += 1

    def on_created(self, event):
        if self.ext is not None:
            if os.path.splitext(event.src_path)[1] in self.ext:
                self.create_counter += 1
        else:
            self.create_counter += 1

    def on_deleted(self, event):
        if self.ext is not None:
            if os.path.splitext(event.src_path)[1] in self.ext:
                self.del_counter += 1
        else:
            self.del_counter += 1

    def file_changes(self):
        if self.mod_counter >= self.max_mod:
            logging.info(f"Warrning! Modified files:  {self.mod_counter} times within {self.time_frame} seconds.")
        if self.create_counter >= self.max_create:
            logging.info(f"Warrning! Created files: {self.create_counter} times within {self.time_frame} seconds.")
        if self.del_counter >= self.max_del:
            logging.info(f"Warrning! Deleted files: {self.del_counter} times within {self.time_frame} seconds.")
        self.mod_counter = 0 
        self.create_counter = 0
        self.del_counter = 0

def monitoring(path, ext=None):
    with daemon.DaemonContext():
        #'/var/log/irondome/irondome.log'
        logging.basicConfig(filename="/var/log/irondome/irondome.log",
                            level=logging.INFO,
                            format='%(asctime)s - %(message)s',
                            datefmt='%Y-%m-%d %H:%M:%S')
        e_handler = Events(path, ext, time_frame=5, max_mod=5, max_create=3, max_del=5)
        observer = Observer()
        observer.schedule(e_handler, path, recursive=True)
        observer.start()
        past_entropy = {}
        #try:
        while True:
            timer = time.time()
            while (time.time() - timer) < e_handler.time_frame:
                memory_usage()
            e_handler.file_changes()
            past_entropy = entropy_changes(path, ext, past_entropy)
        #except:
        #    observer.stop()
        #observer.join()


if __name__ == "__main__":
    args = parse_arguments()
    if is_root_user():
        if len(args.args) > 0:
            if os.path.isdir(args.args[0]):
                if len(args.args) > 1:
                    monitoring(args.args[0], args.args[1:])
                else:
                    monitoring(args.args[0])
            else:
                print("Path is not a directory")
        else:
            print("Usage: ./irondome <monitoring_path> <file_ext(opt)> ... &")
    else:
        print("The program can only be executed by a root user")

